# LARAVEL ÖĞRETİCİ DOKÜMANTASYON
## CodeIgniter'dan Laravel'e Geçiş Rehberi - Eğitim API Projesi

---

## İÇİNDEKİLER
1. [Laravel vs CodeIgniter - Temel Farklar](#1-laravel-vs-codeigniter)
2. [Proje Yapısı ve Dosya Organizasyonu](#2-proje-yapısı)
3. [Model Yapısı (Eloquent ORM)](#3-model-yapısı)
4. [Controller Yapısı](#4-controller-yapısı)
5. [API Resources - Neden ve Nasıl](#5-api-resources)
6. [Migration (Veritabanı Şeması)](#6-migration)
7. [Seeders (Veri Ekleyiciler)](#7-seeders)
8. [Routing (Yönlendirme)](#8-routing)
9. [Validation (Doğrulama)](#9-validation)
10. [Relationships (İlişkiler)](#10-relationships)
11. [Pagination (Sayfalama)](#11-pagination)
12. [Frontend Integration](#12-frontend-integration)

---

## 1. LARAVEL VS CODEIGNITER

### CodeIgniter'da Alışık Olduğunuz Yapı:
```php
// CodeIgniter - Controller
class User extends CI_Controller {
    public function index() {
        $this->load->model('User_model');
        $data['users'] = $this->User_model->get_all();
        $this->load->view('users', $data);
    }
}

// CodeIgniter - Model
class User_model extends CI_Model {
    public function get_all() {
        return $this->db->get('users')->result();
    }
}
```

### Laravel'daki Karşılığı:
```php
// Laravel - Controller
class UserController extends Controller {
    public function index() {
        $users = User::all();
        return view('users', compact('users'));
    }
}

// Laravel - Model (Eloquent)
class User extends Model {
    // Otomatik olarak 'users' tablosunu kullanır
    // get_all() gibi method'lara gerek yok
}
```

### Temel Farklar:
1. **Otomatikleşme**: Laravel çok şeyi otomatik yapar
2. **Eloquent ORM**: SQL yazmaya gerek yok, PHP ile veritabanı işlemleri
3. **Artisan Commands**: Terminal komutları ile dosya oluşturma
4. **Migration**: Veritabanı şemasını kod ile yönetme
5. **Composer**: Paket yöneticisi entegrasyonu

---

## 2. PROJE YAPISI

### Bizim Projemizdeki Dosya Yapısı:
```
egitim-api/
├── app/
│   ├── Http/
│   │   ├── Controllers/
│   │   │   ├── EducationController.php
│   │   │   ├── CategoryController.php
│   │   │   └── TagController.php
│   │   └── Resources/
│   │       ├── EducationResource.php
│   │       ├── CategoryResource.php
│   │       └── TagResource.php
│   └── Models/
│       ├── Education.php
│       ├── Category.php
│       └── Tag.php
├── database/
│   ├── migrations/
│   │   ├── 2024_create_categories_table.php
│   │   ├── 2024_create_tags_table.php
│   │   ├── 2024_create_educations_table.php
│   │   └── 2024_create_education_tag_table.php
│   └── seeders/
│       ├── CategorySeeder.php
│       ├── TagSeeder.php
│       ├── EducationSeeder.php
│       └── DatabaseSeeder.php
├── routes/
│   ├── api.php (API rotaları)
│   └── web.php (Web rotaları)
└── resources/
    └── views/ (Frontend dosyaları)
```

### CodeIgniter'dan Farkları:
- **CodeIgniter**: application/controllers/, application/models/
- **Laravel**: app/Http/Controllers/, app/Models/
- **Migration**: CodeIgniter'da yoktu, Laravel'da veritabanı şeması kod ile yönetiliyor
- **Resources**: API response'larını standardize etmek için

---

## 3. MODEL YAPISI (ELOQUENT ORM)

### CodeIgniter'da Model:
```php
class Education_model extends CI_Model {
    public function get_all() {
        return $this->db->get('educations')->result();
    }
    
    public function get_by_id($id) {
        return $this->db->get_where('educations', ['id' => $id])->row();
    }
    
    public function insert($data) {
        return $this->db->insert('educations', $data);
    }
}
```

### Laravel'da Model (Bizim Education.php):
```php
class Education extends Model
{
    protected $table = 'educations';
    protected $fillable = ['title', 'description', 'content_type', 'start_date', 'category_id'];

    protected $casts = [
        'start_date' => 'date',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
    ];

    public function category() {
        return $this->belongsTo(Category::class);
    }

    public function tags() {
        return $this->belongsToMany(Tag::class);
    }
}
```

### Laravel Model'inin Avantajları:
1. **Otomatik CRUD**: `Education::all()`, `Education::find(1)`, `Education::create()`
2. **Relationships**: İlişkileri tek satırda tanımlama
3. **Casts**: Veri tiplerini otomatik dönüştürme
4. **Fillable**: Hangi alanların doldurulabileceğini belirleme
5. **Timestamps**: created_at, updated_at otomatik yönetimi

### Kullanım Örnekleri:
```php
// Tüm eğitimleri getir
$educations = Education::all();

// ID ile getir
$education = Education::find(1);

// Kategori ile birlikte getir (Eager Loading)
$education = Education::with('category')->find(1);

// Yeni eğitim oluştur
$education = Education::create([
    'title' => 'Laravel Kursu',
    'description' => 'Kapsamlı Laravel eğitimi',
    'content_type' => 'video',
    'start_date' => '2024-01-15',
    'category_id' => 1
]);

// Güncelle
$education->update(['title' => 'Yeni Başlık']);

// Sil
$education->delete();
```

---

## 4. CONTROLLER YAPISI

### CodeIgniter Controller'ından Farklar:

**CodeIgniter**:
```php
class Education extends CI_Controller {
    public function __construct() {
        parent::__construct();
        $this->load->model('Education_model');
    }
    
    public function index() {
        $data['educations'] = $this->Education_model->get_all();
        $this->load->view('educations', $data);
    }
}
```

**Laravel** (Bizim EducationController.php):
```php
class EducationController extends Controller
{
    public function index() {
        $educations = Education::with(['category', 'tags'])
            ->paginate(10);
        
        return EducationResource::collection($educations);
    }
    
    public function store(Request $request) {
        $validated = $request->validate([
            'title' => 'required|string|max:255',
            'description' => 'required|string',
            'content_type' => 'required|in:video,article,course',
            'start_date' => 'required|date',
            'category_id' => 'required|exists:categories,id',
            'tag_ids' => 'array',
            'tag_ids.*' => 'exists:tags,id'
        ]);

        $education = Education::create($validated);
        
        if ($request->has('tag_ids')) {
            $education->tags()->sync($request->tag_ids);
        }

        return new EducationResource($education->load(['category', 'tags']));
    }
}
```

### Laravel Controller'ın Özellikleri:
1. **Otomatik Model Yükleme**: `use` ile model import
2. **Built-in Validation**: `$request->validate()`
3. **Resource Response**: Standardize JSON çıktı
4. **Eloquent Relationships**: `with()`, `sync()` gibi methodlar
5. **Pagination**: `paginate()` ile otomatik sayfalama

---

## 5. API RESOURCES - NEDEN VE NASIL

### Resources Neden Eklendi?

**Problem**: Model'den gelen veri doğrudan JSON'a dönüştürülünce:
```json
{
    "id": 1,
    "title": "Laravel Kursu",
    "description": "...",
    "category_id": 1,
    "created_at": "2024-01-15T10:30:00.000000Z",
    "updated_at": "2024-01-15T10:30:00.000000Z"
}
```

**Sorunlar**:
- Gereksiz alanlar (category_id vs category bilgisi)
- Tarih formatı kullanıcı dostu değil
- İlişkili veriler dahil değil
- Standardizasyon yok

**Çözüm - EducationResource.php**:
```php
class EducationResource extends JsonResource
{
    public function toArray(Request $request): array
    {
        return [
            'id' => $this->id,
            'title' => $this->title,
            'description' => $this->description,
            'content_type' => $this->content_type,
            'start_date' => $this->start_date?->format('Y-m-d'),
            'category' => new CategoryResource($this->whenLoaded('category')),
            'tags' => TagResource::collection($this->whenLoaded('tags')),
            'created_at' => $this->created_at?->format('Y-m-d H:i:s'),
            'updated_at' => $this->updated_at?->format('Y-m-d H:i:s'),
        ];
    }
}
```

**Sonuç**:
```json
{
    "id": 1,
    "title": "Laravel Kursu",
    "description": "Kapsamlı Laravel eğitimi",
    "content_type": "video",
    "start_date": "2024-01-15",
    "category": {
        "id": 1,
        "name": "Programming",
        "description": "Programming related courses"
    },
    "tags": [
        {"id": 1, "name": "PHP", "description": "PHP programming language"},
        {"id": 2, "name": "Laravel", "description": "Laravel framework"}
    ],
    "created_at": "2024-01-15 10:30:00",
    "updated_at": "2024-01-15 10:30:00"
}
```

### Resource'ların Avantajları:
1. **Veri Kontrolü**: Hangi alanların döneceğini kontrol edebilirsiniz
2. **Format Standardizasyonu**: Tarih/saat formatları
3. **İlişki Yönetimi**: `whenLoaded()` ile N+1 problem'ini önleme
4. **Güvenlik**: Hassas verileri gizleme
5. **Tutarlılık**: Tüm API endpoint'lerinde aynı format

---

## 6. MIGRATION (VERİTABANI ŞEMASI)

### CodeIgniter'da Veritabanı:
- Genelde phpMyAdmin ile tablo oluşturma
- SQL dosyaları manuel import
- Değişiklik takibi zor

### Laravel Migration (Bizim create_educations_table.php):
```php
public function up(): void
{
    Schema::create('educations', function (Blueprint $table) {
        $table->id();
        $table->string('title');
        $table->text('description');
        $table->enum('content_type', ['video', 'article', 'course']);
        $table->date('start_date');
        $table->foreignId('category_id')->constrained()->onDelete('cascade');
        $table->timestamps();
    });
}

public function down(): void
{
    Schema::dropIfExists('educations');
}
```

### Migration'ın Avantajları:
1. **Versiyon Kontrolü**: Git ile veritabanı değişiklikleri takip edilir
2. **Ekip Çalışması**: Herkes aynı veritabanı yapısına sahip
3. **Rollback**: `down()` method'u ile geri alma
4. **Otomatik Foreign Key**: `constrained()` ile ilişki kurma
5. **Data Type Güvenliği**: Blueprint ile tip kontrolü

### Migration Komutları:
```bash
# Migration oluştur
php artisan make:migration create_educations_table

# Migration'ları çalıştır
php artisan migrate

# Son migration'ı geri al
php artisan migrate:rollback

# Tüm migration'ları geri al ve tekrar çalıştır
php artisan migrate:fresh
```

---

## 7. SEEDERS (VERİ EKLEYİCİLER)

### Seeder Nedir ve Neden Gerekli?

**CodeIgniter'da**: Test verileri genelde manuel SQL ile eklenir
**Laravel'da**: Seeder'lar ile otomatik test verisi

### Bizim CategorySeeder.php Örneği:
```php
public function run(): void
{
    $categories = [
        ['name' => 'Programming', 'description' => 'Programming related courses'],
        ['name' => 'Design', 'description' => 'Design and UI/UX courses'],
        ['name' => 'Marketing', 'description' => 'Digital marketing courses'],
        // ... diğer kategoriler
    ];

    foreach ($categories as $category) {
        Category::create($category);
    }
}
```

### Seeder'ların Faydaları:
1. **Hızlı Başlangıç**: Projede hemen çalışabilir veri
2. **Test Ortamı**: Development için tutarlı veri
3. **Demo**: Müşterilere gösterim için hazır içerik
4. **Ekip Çalışması**: Herkesin aynı test verisi
5. **Production Hazırlığı**: İlk veriler otomatik eklenir

### DatabaseSeeder.php - Ana Seeder:
```php
public function run(): void
{
    $this->call([
        CategorySeeder::class,    // Önce kategoriler
        TagSeeder::class,         // Sonra tag'ler
        EducationSeeder::class,   // En son eğitimler (foreign key'ler için)
    ]);
}
```

### Seeder Komutları:
```bash
# Seeder oluştur
php artisan make:seeder CategorySeeder

# Seeder'ları çalıştır
php artisan db:seed

# Belirli seeder çalıştır
php artisan db:seed --class=CategorySeeder

# Migration + Seeder birlikte
php artisan migrate:fresh --seed
```

---

## 8. ROUTING (YÖNLENDİRME)

### CodeIgniter Routing:
```php
// routes.php
$route['education'] = 'education/index';
$route['education/view/(:num)'] = 'education/view/$1';
```

### Laravel API Routes (api.php):
```php
Route::apiResource('educations', EducationController::class);
Route::apiResource('categories', CategoryController::class);
Route::apiResource('tags', TagController::class);
```

Bu tek satır aşağıdaki route'ları oluşturur:
```
GET    /api/educations          -> index()    (Tümünü listele)
POST   /api/educations          -> store()    (Yeni oluştur)
GET    /api/educations/{id}     -> show()     (Tekil göster)
PUT    /api/educations/{id}     -> update()   (Güncelle)
DELETE /api/educations/{id}     -> destroy()  (Sil)
```

### Laravel Web Routes (web.php):
```php
Route::get('/', function () {
    return view('dashboard');
})->name('dashboard');

Route::get('/educations', function () {
    return view('educations');
})->name('educations');
```

### Route'ların Özellikleri:
1. **RESTful**: Otomatik REST API pattern'i
2. **Resource Routes**: CRUD için tek satır
3. **Named Routes**: `route('educations')` ile URL oluşturma
4. **Middleware**: Authentication, CORS vs. kolayca ekleme
5. **Route Model Binding**: Otomatik model yükleme

---

## 9. VALIDATION (DOĞRULAMA)

### CodeIgniter'da Validation:
```php
$this->load->library('form_validation');
$this->form_validation->set_rules('title', 'Title', 'required');
if ($this->form_validation->run() == FALSE) {
    // Hata
}
```

### Laravel'da Validation (Controller'ımızda):
```php
$validated = $request->validate([
    'title' => 'required|string|max:255',
    'description' => 'required|string',
    'content_type' => 'required|in:video,article,course',
    'start_date' => 'required|date',
    'category_id' => 'required|exists:categories,id',
    'tag_ids' => 'array',
    'tag_ids.*' => 'exists:tags,id'
]);
```

### Validation Rules Açıklaması:
- `required`: Zorunlu alan
- `string`: Metin olmalı
- `max:255`: Maksimum 255 karakter
- `in:video,article,course`: Bu değerlerden biri olmalı
- `date`: Geçerli tarih formatı
- `exists:categories,id`: categories tablosunda bu id var mı?
- `array`: Dizi olmalı
- `tag_ids.*`: Dizinin her elemanı için kural

### Otomatik Error Response:
Laravel validation fail olursa otomatik 422 status ile hata döner:
```json
{
    "message": "The given data was invalid.",
    "errors": {
        "title": ["The title field is required."],
        "category_id": ["The selected category id is invalid."]
    }
}
```

---

## 10. RELATIONSHIPS (İLİŞKİLER)

### CodeIgniter'da İlişkiler:
```php
// Manual JOIN
$this->db->select('educations.*, categories.name as category_name');
$this->db->from('educations');
$this->db->join('categories', 'categories.id = educations.category_id');
$result = $this->db->get()->result();
```

### Laravel Eloquent Relationships:

#### 1. One-to-Many (Education -> Category):
```php
// Education Model
public function category() {
    return $this->belongsTo(Category::class);
}

// Category Model  
public function educations() {
    return $this->hasMany(Education::class);
}

// Kullanım
$education = Education::with('category')->find(1);
echo $education->category->name;

$category = Category::with('educations')->find(1);
foreach($category->educations as $education) {
    echo $education->title;
}
```

#### 2. Many-to-Many (Education <-> Tag):
```php
// Education Model
public function tags() {
    return $this->belongsToMany(Tag::class);
}

// Tag Model
public function educations() {
    return $this->belongsToMany(Education::class);
}

// Kullanım - Tag ekleme/çıkarma
$education = Education::find(1);
$education->tags()->attach([1, 2, 3]);    // Tag ekle
$education->tags()->detach([2]);          // Tag çıkar
$education->tags()->sync([1, 3, 4]);      // Sadece bunları bırak
```

### Eager Loading vs Lazy Loading:
```php
// N+1 Problem (BAD)
$educations = Education::all();
foreach($educations as $education) {
    echo $education->category->name; // Her biri için ayrı sorgu!
}

// Eager Loading (GOOD)
$educations = Education::with('category')->get();
foreach($educations as $education) {
    echo $education->category->name; // Tek sorguda tüm kategoriler yüklenmiş
}
```

---

## 11. PAGINATION (SAYFALAMA)

### CodeIgniter'da Pagination:
```php
$this->load->library('pagination');
$config['base_url'] = base_url('education/index');
$config['total_rows'] = $this->Education_model->count_all();
$config['per_page'] = 10;
$this->pagination->initialize($config);
```

### Laravel'da Pagination:
```php
// Controller'da
$educations = Education::with(['category', 'tags'])->paginate(10);
return EducationResource::collection($educations);
```

Otomatik olarak şu JSON çıktısını verir:
```json
{
    "data": [
        // Eğitim verileri
    ],
    "links": {
        "first": "http://localhost/api/educations?page=1",
        "last": "http://localhost/api/educations?page=5",
        "prev": null,
        "next": "http://localhost/api/educations?page=2"
    },
    "meta": {
        "current_page": 1,
        "from": 1,
        "last_page": 5,
        "per_page": 10,
        "to": 10,
        "total": 50
    }
}
```

### Pagination Avantajları:
1. **Otomatik Link Oluşturma**: Prev/Next URL'ler
2. **Meta Bilgiler**: Toplam sayfa, mevcut sayfa vs.
3. **Performance**: Büyük veri setlerinde hız
4. **Resource Integration**: Collection ile uyumlu

---

## 12. FRONTEND INTEGRATION

### Laravel + Frontend Bağlantısı:

#### 1. Web Routes (Frontend):
```php
Route::get('/', function () {
    return view('dashboard');
})->name('dashboard');
```

#### 2. API Routes (Backend):
```php
Route::apiResource('educations', EducationController::class);
```

#### 3. Frontend AJAX Kullanımı:
```javascript
// Eğitimleri yükle
function loadEducations(page = 1) {
    $.get(`/api/educations?page=${page}`)
        .done(function(response) {
            renderEducations(response.data);
            renderPagination(response.meta);
        });
}

// Yeni eğitim oluştur
function createEducation(formData) {
    $.ajax({
        url: '/api/educations',
        method: 'POST',
        data: formData,
        success: function(response) {
            loadEducations(); // Listeyi yenile
            $('#educationModal').modal('hide');
        },
        error: function(xhr) {
            showValidationErrors(xhr.responseJSON.errors);
        }
    });
}
```

---

## EKLENEN EKSİKLİKLER VE NEDENLERİ

### 1. .env.example Dosyası
**Neden Eklendi**: 
- Yeni geliştirici projeyi klonladığında hangi environment variable'ların gerekli olduğunu bilsin
- Production'da farklı, development'da farklı ayarlar

**İçeriği**:
```
APP_NAME=Egitim-API
APP_ENV=local
APP_KEY=
APP_DEBUG=true
APP_URL=http://localhost

DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=egitim_api
DB_USERNAME=root
DB_PASSWORD=
```

### 2. API Resources
**Neden Eklendi**:
- JSON çıktısını standardize etmek
- Frontend'e tutarlı veri formatı sağlamak
- Gereksiz alanları gizlemek
- İlişkili verileri kontrollü şekilde dahil etmek

### 3. Seeders
**Neden Eklendi**:
- Development ortamında çalışabilir veri
- Demo için hazır içerik
- Test senaryoları için tutarlı data
- Yeni geliştirici hızlı başlangıç

### 4. Comprehensive Validation
**Neden Eklendi**:
- Veri bütünlüğü sağlamak
- Frontend'e anlamlı hata mesajları
- Database constraint'leri kod seviyesinde kontrol
- Security (SQL injection vs. önleme)

### 5. Proper Error Handling
**Neden Eklendi**:
- Production'da kullanıcı dostu hata mesajları
- Development'da debug bilgisi
- API'da tutarlı error format
- HTTP status code'ları doğru kullanım

---

## LARAVEL'İN CODINITER'DAN ÜSTÜNLÜKLERİ

### 1. Otomatikleşme
- **CodeIgniter**: Her şeyi manuel yazmalısınız
- **Laravel**: Convention over configuration

### 2. ORM (Object Relational Mapping)
- **CodeIgniter**: SQL yazarak veritabanı işlemleri
- **Laravel**: PHP objesi gibi veritabanı kullanımı

### 3. Artisan Commands
- **CodeIgniter**: Dosyaları manuel oluşturma
- **Laravel**: `php artisan make:model User` ile otomatik

### 4. Package Management
- **CodeIgniter**: Library'leri manuel indirme
- **Laravel**: Composer ile paket yönetimi

### 5. Testing
- **CodeIgniter**: Test yazmak zor
- **Laravel**: Built-in PHPUnit entegrasyonu

### 6. Security
- **CodeIgniter**: Manuel güvenlik önlemleri
- **Laravel**: Otomatik CSRF, XSS protection

---

## SONUÇ

Bu proje ile Laravel'in temel özelliklerini öğrendiniz:

✅ **Model-View-Controller Pattern**
✅ **Eloquent ORM ile veritabanı işlemleri**
✅ **Migration ile veritabanı yönetimi**
✅ **Seeder ile test verisi oluşturma**
✅ **API Resource ile JSON standardizasyonu**
✅ **Validation ile veri doğrulama**
✅ **Relationship ile tablo ilişkileri**
✅ **Pagination ile performans optimizasyonu**
✅ **RESTful API geliştirme**
✅ **Frontend-Backend entegrasyonu**

Laravel, CodeIgniter'a göre daha fazla convention ve otomatikleşme sunar. Başlangıçta öğrenme eğrisi olabilir, ancak büyük projelerde çok daha hızlı ve verimli geliştirme sağlar.

### Sonraki Adımlar:
1. **Authentication**: API token'ları ile güvenlik
2. **Testing**: Feature ve Unit testler yazma
3. **Queue**: Arka plan işleri (email gönderimi vs.)
4. **Events**: Olay tabanlı programlama
5. **Cache**: Performance optimizasyonu
6. **Docker**: Container'larla deployment
